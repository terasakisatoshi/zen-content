---
title: "GomalizingFlow.jl 入門(Part1)"
emoji: "🦭"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["Julia", "azarashi"]
published: false
---

# 本日は

[計算物理 春の学校 ２０２３](https://hohno0223.github.io/comp_phys_spring_school2023/) に参加された皆さんお疲れ様でした. ここでは [GomalizingFlow.jl](https://github.com/AtelierArith/GomalizingFlow.jl) に対するチュートリアルを書きます.

https://github.com/AtelierArith/GomalizingFlow.jl

# GomalizingFlow.jl について

GomalizingFlow.jl は格子上の場の理論, 特にスカラー場 $\phi^4$ 理論, における flow-based サンプリングを用いた配位生成アルゴリズムを提供するパッケージです．
プログラミング言語 Julia で書かれたものです. 実装のベースになったのは下記のツイートで紹介されている論文です:

https://twitter.com/MLPhysJP/status/1554395703429906433?s=20

[Introduction to Normalizing Flows for Lattice Field Theory](https://arxiv.org/abs/2101.08176) も参考にしました．

# 格子上の場の理論

場の理論， (または場の量子論)は素粒子物理学の世界を記述する際に用いられる理論です.
その中で格子上の場の理論と言った場合, 連続的な時空間を離散化し時空間を有限の格子点の集まりとみなします． 場はその格子を用いて定義されたもとで数値計算や理論を展開することになります．

この立場では下記で述べるような数学的な定式化が可能になり, コードとして落とし込めることができます.

$d$ を時空の次元とします. $L$ を正の整数とします. 各方向のサイズが $L$ である格子点の集合を次で定めます:

$$
\mathcal{L} \coloneqq \{n = (n_1, \dots, n_d) \mid n_\mu \in \{1,2,\dots, L\}, \mu \in \{1,\dots, d\} \} \subset \mathbb{R}^d
$$

この $\mathcal{L}$ が $d$ 次元の離散化された時空に対応します. ここではスカラー場 $\phi$ の場合のみを考えます.
スカラー場 $\phi$ は形式的には $n \in \mathcal{L}$ 上の関数 $\phi=\phi(n)$ですが, 実際にコードを読むときは格子 $\mathcal{L}$ の位置 $n$ に実数値 $\phi(n)$ が配置されているオブジェクトとみなした方が良いかもしれません.
プログラム上だと $d=2$ だと行列, $d=3, 4$ では多次元配列として解釈できます. このオブジェクトを配位(configuration)と呼び, これも単に $\phi$ と書くことにします. スカラー場 $\phi^4$ 理論の設定では配位 $\phi$ は次の分布に従って与えられます:

$$\phi \sim P[\phi] = \exp(-S[\phi])/Z$$

ここで $S$ はユークリッド作用と呼ばれるものです. ここでは配位 $\phi$ を与えたら実数値を与えるものだと思いましょう. 後で具体的な $S$ は後で与えます. $Z$ は分配関数とよばれ積分の規格化因子として定ります:

$$
Z = \int \mathcal{D}\phi \exp(-S[\phi]).
$$

ここで $\mathcal{D}\phi$ は

$$
\mathcal{D}\phi = \prod_{n\in\mathcal{L}} d\phi(n)
$$

のことを表します. 例えば 3 変数の関数 $f=f(x_1, x_2, x_3)$ を積分するときに

$$\int dx_1dx_2dx_3 f(x_1, x_2, x_3)$$

のような記号を使うと思いますが, その時の $dx_1dx_2dx_3$ を $\prod_{n} dx_n$ のように書いていると思ってください. $d\phi(n)$ は $n \in \mathcal{L}$ で添字づけられた変数だと思えば良いです.

放置していたユークリッド作用 $S$ の説明に戻ります. 配位 $\phi$ に対してスカラー場 $\phi^4$ 理論に対応する作用 $S[\phi]$ を次で定義します:

$$
S[\phi]= - \sum_{n\in\mathcal{L}}\phi(n)\partial^2\phi(n) + \sum_{n\in \mathcal{L}} V[\phi](n)
$$

ここで, $V[\phi]$ はポテンシャル項と呼ばれ $n\in\mathcal{L}$ に対して

$$V[\phi](n) = m^2\phi(n) + \lambda \phi^4(n)$$

で与えられるものだとします. $m^2$ や $\lambda$ は定数です. 文献によっては $1/2$ や $1/4!$ をつけることが多いと思いますがここではつけていません.

$\partial^2\phi$ は離散ラプラシアンです. 具体的には下記のようになります:

$$
\partial^2\phi(n) = \sum_{\mu=1}^d(\phi(n + \hat{\mu}) + \phi(n - \hat{\mu}) - 2\phi(n)).
$$

さらに $n + \hat{\mu}$ の記号の説明も必要です. $n$ は格子 $\mathcal{L}$ の点であったことに注意しましょう. $n+\hat{\mu}$ は $d$ 次元空間の $\mu$ 軸の方向に対し $n$ を出発点とし一歩進んだ点を表します. $n - \hat{\mu}$ は $n$ を出発点とし $\mu$ 軸のマイナス方向に一歩進んだ点だとします. なお, 格子 $\mathcal{L}$ には境界条件は周期境界条件を採用することにします.

これで格子上のスカラー $\phi^4$ 理論を導入することができました. 定数 $d, L, m^2, \lambda$ を与えればそこから機械的に上記の定めた定義式を求め，配位の分布の定義を数学的に(形式的にかつ厳密に)与えられることがわかるでしょう.

時空間を格子にせず連続したまま取り扱うと $Z$ の定義式は無限次元の多重積分になります. つまり $\mathcal{D}\phi$ は

$$
\mathcal{D}\phi = \prod_{x \in \mathbb{R}^d} \phi(x)
$$

という計算を行う必要が出てきます. このような問題点を回避するために格子の場の理論が有効です. また格子上で考えることで上記で述べたように理論を形式的に定義することができるのも魅力的です. この時点で場の理論そもそもわからずチンプンカンプンになってるかもしれませんが， とりあえず問題設定を形式的に理解することができれば OK です.

# 格子上の場の理論における計算

ところで, 場の理論は量子力学と特殊相対性理論を土台にした理論です. 特に量子論の要請から物理量 $O$ は確率的に振る舞います.

$$\langle O \rangle = \int \mathcal{D}\phi P[\phi]O[\phi]$$

によって期待値を得ます. どうやらこの計算ができれば人類は幸せになれるようです.

$P[\phi]$ がなんだったかを思い出すには $Z$ と $S$ が分かればよかったです. $S$ に関しては

$$
S[\phi]= - \sum_{n\in\mathcal{L}}\phi(n)\partial^2\phi(n) + \sum_{n\in \mathcal{L}} V[\phi](n)
$$

で与えられるものでした. 配位 $\phi$ は格子上の点 $n\in \mathcal{L}$ に対して実数値が乗っかっているオブジェクトとおもえばOKでした. あとは右辺の式一つ一つを思い出せば機械的に計算できるようになってます. ここでの機械的というのは適切な定式化のもとでプログラムに落とし込めるという意味です. ひとまず理論物理がチンプンカンプンでも色々割り切って積分を数値計算を行えば人類に貢献できそうという一つの拠り所ができたのではないでしょうか.

# 高次元の積分の壁

上記の方針は間違ってないですが， 現実世界で計算機を走らせると大変なことになります. $d=4, L=10$ の場合, 格子点は $L^d = 10000$ 点になります. 我々が考えている積分の定義上, その数を変数とした多次元の多重積分を実行していることになります.（とても膨大ですが非加算無限の濃度の変数に関する多重積分を考えるよりはマシですね）.

この規模の高次元積分を台形公式などを使って真面目にすると現実時間では終わらないことが知られています([富谷さんの格子QCDの講義ノートを参照](https://hohno0223.github.io/comp_phys_spring_school2023/)).

困った. この手の計算では乱数を用いたモンテカルロ法をよく使います.

$$\langle O \rangle = \int \mathcal{D}\phi P[\phi]O[\phi]$$

を計算するために分布 $P$ に従う配位をサンプルします. 例えば $\phi_1, \phi_2, \dots, \phi_N$ としましょう.
$\langle O \rangle$ の計算を下記によって実現させることにします:

$$
\frac{1}{N}\sum_{i=1}^N O[\phi_i]
$$

この平均値のの期待値は $\langle O \rangle$ と一致し 誤差は $1/\sqrt{N}$ のオーダで減少することがわかります. 

ひとまず, 配位をいっぱい生成する手段が確立できれば積分対象の次元の高さに依らず
生成された配位から定まる物理量の平均を計算することに集中すれば良いことになります. 

# マルコフ連鎖モンテカルロ法による配位の生成

格子上の場の理論のテキストを読むと配位の生成のやり方としてマルコフ連鎖モンテカルロ法 (MCMC) の一つである ハミルトニアンモンテカルロ法(HMC) がよく使われます. [LatticeQCD.jl](https://github.com/akio-tomiya/LatticeQCD.jl) の README に書いてあるように LatticeQCD.jl は配位生成アリゴリズムとして HMC を採用した機能を提供しています. 自己学習モンテカルロ法 (SLMC) を使った手法も提供しているようです. SLMC については LatticeQCD.jl の開発者の一人である永井さんの解説 [自己学習モンテカルロ法：機械学習を用いたマルコフ連鎖モンテカルロ法の加速](https://www.jstage.jst.go.jp/article/mssj/21/1/21_15/_pdf/-char/ja) がとてもわかりやすいです. GomalizingFlow.jl も配位生成をする際に SLMC を使います.

簡単にですが, マルコフ連鎖モンテカルロ法を思い出します. これは点列

$$
x_0, x_1, x_2, \dots, x_k, x_{k+1}, \dots
$$

を逐次構成し所望の分布 $P=P(x)$ に収束させるアルゴリズムでした. $x_{k+1}$ は $x_{k}$ にのみによって決まります. ある $x$ から $x^\prime$ へ遷移する確率を $T(x \rightarrow x^\prime)$ のようにして書くとしましょう. 遷移確率と呼ばれる $T$ は所望の分布 $P$ との詳細つりあい条件

$$
P(x) T(x \rightarrow x^\prime) = P(x^\prime) T(x^\prime \rightarrow x)
$$

を満たすように設計することで関数 $O=O(x)$ の期待値を 

$$
\langle O \rangle = \int dx\ O(x) P(x) = \lim_{K\to\infty}\frac{1}{K}\sum_{k=1}^K f(x_k)
$$

によって得ることができるものでした. メトロポリス・ヘイスティング法は遷移確率 $T$ を提案確率 $f(x \to x^\prime)$ と 採択確率(または受理確率) $A( x \to x^\prime)$ に分解します:

$$
T(x\to x^\prime) = f(x \to x^\prime)A( x \to x^\prime)
$$

$A( x \to x^\prime)$ は詳細つりあい条件を満たすように

$$
A( x \to x^\prime) = \min\left(1, \frac{P(x^\prime) f(x^\prime \to x)}{P(x)f(x \to x^\prime)}\right)
$$

のようにして与えられます. アルゴリズムの $k$ ステップ目において $x_k$ があるとした時に $f$ 君が $x_{k+1}$ を「作ってええか？」と $A$ さんに尋ねます. $A$ さんは $\min$ の中にある式を計算の計算次第で「ええよ！ $f$ 君がくれた $x_{k+1}$ を採択するよ！」, 「やだ! $x_{k+1}$ は $x_k$ にするもん！」という採択または棄却するやりとりが聞こえるようになります. [ゼロからできるMCMC](https://www.kspub.co.jp/book/detail/5201749.html) に触れられているようにメトロポリス法, ギブスサンプリング, HMC などは今述べたメトロポリス・ヘイスティングの特別な場合と理解することもできます. 

さて，人間にとっては採択する確率が低い(棄却される頻度が多い)と

$$
x_0, x_1, x_2, \dots, x_k, x_{k+1}, \dots x_N
$$

という点列の間に相関が出てきます. （極端な例として）例えば `1,1,4,4,2,2,3,3` として得られたデータの平均を求めたいとします. 偶数版目のデータは 一つ手前のデータと相関があります. これは実質 `1,4,2,3` という独立に得た 4 点のデータから求めるのと同じ程度の精度しか得られません. 得られる乱数の質が悪いと所望の誤差内にて計算するのに必要なサンプル数を増やす必要があります. 

誤差はルートNのオーダーで制御できます. これは精度を１桁改善するには必要なサンプル数の桁を2つ増やす必要を意味します:

```julia
julia> 1/sqrt(100)
0.1

julia> 1/sqrt(10000)
0.01

julia> 1/sqrt(1000000)
0.001
```

したがって相関が少ないサンプル方法が望まれています. 相関の話は下記のリストを参照してください.

- ゼロからできるMCMC](https://www.kspub.co.jp/book/detail/5201749.html)
- [富谷さんの格子QCDの講義ノートを参照](https://hohno0223.github.io/comp_phys_spring_school2023/)

今考えているメトロポリス・ヘイスティング法の文脈では $A$ さんが「ええよ！」と採択する確率が 1 に近づくようにすれば改善できます.

SLMC では「これでええか？」と尋ねる提案確率 $f(x\to x^\prime)$ として目標とする分布 $P$ を近似する $\tilde{P}=\tilde{P}(x^\prime)$　を設計するアプローチを取ります. いい感じの $\tilde{P}$ を設計できれば採択確率 $A$ の式は

$$
A(x \to x^\prime) = \min\left(1, \frac{P(x^\prime)\tilde{P}(x)}{P(x)\tilde{P}(x^\prime)} \right)
$$

となります. $\min$ の 2 番目の引数が なるべく 1 になる (理想を言えば $P = \tilde{P}$) ようになれば良いわけです. 

GomalizingFlow.jl ではスカラー場のための $\tilde{P}$ の設計として Normalizing Flow による手法を実装しています.
ここまでくると場の理論の文脈は薄れ機械学習の文脈になります. 後述するように $\tilde{P}$ がニューラルネットワークを用いた機械学習モデルとなっており, 学習によりスカラー場の配位生成を可能とします.

# Flow-based models

Flow-based の flow の気持ちになるためにボックス・ミュラー法を思い出します.

$$
\begin{aligned}
z_1 &= \sqrt{-2\log(x)} \cos (2\pi y), && \\
z_2 &= \sqrt{-2\log(x)} \sin (2\pi y)
\end{aligned}
$$

という変換を考えます. $x$, $y$ は各々開区間 $(0, 1)$ を動くものとします. $r = \sqrt{-2\log(x)}, \theta = 2\pi y$ と思えばみんな大好き極座標表示です. 

